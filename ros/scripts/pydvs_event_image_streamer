#!/usr/bin/env python3

import sys
import argparse

import rospy
import cv2

from event_camera_emulation.emulator import EventCameraEmulator

from cv_bridge import CvBridge, CvBridgeError
from sensor_msgs.msg import Image

## From pyDVS scripts:
import pydvs.generate_spikes as gs
import multiprocessing
from multiprocessing import Process, Queue, Value
import numpy as np

## +++ Ahmed: Analyzing data:
import pickle

camera_device_ = None
bridge = CvBridge()

image_publisher_ = None
visual_events_image_publisher_ = None
current_image_msg_ = None

## pyDVS Initializations:
## -------------------------------------------------------------------------
# cam_res = 128
cam_res = 480
width = cam_res # square output
height = cam_res
shape = (height, width)

UP_POLARITY     = "UP"
DOWN_POLARITY   = "DOWN"
MERGED_POLARITY = "MERGED"
POLARITY_DICT   = {UP_POLARITY: np.uint8(0), 
                   DOWN_POLARITY: np.uint8(1), 
                   MERGED_POLARITY: np.uint8(2),
                   0: UP_POLARITY,
                   1: DOWN_POLARITY,
                   2: MERGED_POLARITY}
polarity = POLARITY_DICT[ MERGED_POLARITY ]
# output_type = OUTPUT_TIME
history_weight = 1.0
threshold = 12 # ~ 0.05*255
threshold = 20
# max_threshold = 180 # 12*15 ~ 0.7*255
scale_width = 0
scale_height = 0
col_from = 0
col_to = 0
curr = np.zeros(shape, dtype=np.int16) 
img = np.zeros(shape, dtype=np.int16) 
# ref = 128 * np.ones(shape, dtype=np.int16) 
ref = cam_res * np.ones(shape, dtype=np.int16) 

inh_width = 2
is_inh_on = False
inh_coords = gs.generate_inh_coords(width, height, inh_width)

# fps = video_dev.get(cv2.CAP_PROP_FPS)
fps = 30
max_time_ms = int(1000./fps)

spikes_copy_queue = None

def image_callback(msg):
    global current_image_msg_
    current_image_msg_ = msg

def get_visual_events_image_pydvs(spikes, polarity_key='MERGED'):
    visual_events_image = np.full((spikes.shape[0], spikes.shape[1], 3), 255., dtype='uint8')

    if polarity_key == 'MERGED':
        visual_events_image[spikes == 1] = [255., 0., 0.]
#     visual_events_image[spikes == 2] = [0., 0., 255.]

    return visual_events_image


## pyDVS Thread Functions:
## -------------------------------------------------------------------------
# def emitting_thread(spike_queue, running):
#     while True:
#         spikes = spike_queue.get()

#         if spikes is None or running.value == 0:
#           running.value = 0
#           break
      
#     running.value = 0

def processing_thread(img_queue, spike_queue, running, max_time_ms, spikes_copy_queue):
    global shape, height, width
    # cv2.namedWindow('spikes', cv2.WINDOW_AUTOSIZE)
    # cv2.startWindowThread()

    spikes   = np.zeros(shape, dtype=np.int16) 
    diff     = np.zeros(shape, dtype=np.int16) 
    abs_diff = np.zeros(shape, dtype=np.int16) 

    # # just to see things in a window
    # spk_img  = np.zeros((height, width, 3), np.uint8)

    num_bits = 6   # how many bits are used to represent exceeded thresholds
    num_active_bits = 2 # how many of bits are active
    log2_table = gs.generate_log2_table(num_active_bits, num_bits)[num_active_bits - 1]
    # spike_lists = None
    # pos_spks = None
    # neg_spks = None
    # max_diff = 0

    while True:
        img = img_queue.get()

        if img is None or running.value == 0:
            running.value = 0
            break

        # do the difference
        diff[:], abs_diff[:], spikes[:] = gs.thresholded_difference(img, ref, threshold)

        # inhibition ( optional ) 
        if is_inh_on:
            spikes[:] = gs.local_inhibition(spikes, abs_diff, inh_coords, 
                                       width, height, inh_width)

        # update the reference
        ref[:] = gs.update_reference_time_binary_thresh(abs_diff, spikes, ref,
                                                     threshold, max_time_ms,
                                                     num_active_bits,
                                                     history_weight,
                                                     log2_table)

        spikes_copy_queue.put(spikes)

        # # convert into a set of packages to send out
        # neg_spks, pos_spks, max_diff = gs.split_spikes(spikes, abs_diff, polarity)

        # # this takes too long, could be parallelized at expense of memory
        # spike_lists = gs.make_spike_lists_time_bin_thr(pos_spks, neg_spks,
        #                                             max_diff,
        #                                             up_down_shift, data_shift, data_mask,
        #                                             max_time_ms,
        #                                             threshold, 
        #                                             max_threshold,
        #                                             num_bits,
        #                                             log2_table)

        # spike_queue.put(spike_lists)

        ## +++ Ahmed: Analyzing data:
        with open('/home/ahmed/tmp/pydvs_spikes.pkl', 'wb') as f:
            pickle.dump(spikes, f)

        # spk_img[:] = gs.render_frame(spikes, img, cam_res, cam_res, polarity)
        # cv2.imshow ('spikes', spk_img.astype(np.uint8))  
        # if cv2.waitKey(1) & 0xFF == ord('q'):
        #     running.value = 0
        #     break

    # cv2.destroyAllWindows()  
    # cv2.waitKey(1)
    running.value = 0

def preprocess_img_for_pydvs(img, width, height, col_from, col_to):
    img = cv2.resize(cv2.cvtColor(img, cv2.COLOR_BGR2GRAY).astype(np.int16),
               (new_width, new_height))[:, col_from:col_to]

    return img


if __name__ == '__main__':
    rospy.init_node('event_image_streamer')
    rate = rospy.Rate(30)         # currently highest achievable

    source_type = rospy.get_param('~source_type', 'camera_device')
    publish_output = rospy.get_param('~publish_output', True)
    display_output = rospy.get_param('~display_output', False)
    display_combined_images = rospy.get_param('~display_combined_images', True)
    theta = rospy.get_param('~theta', 60)
    record_off_events = rospy.get_param('~record_off_events', True)
    register_off_events_as_on = rospy.get_param('~register_off_events_as_on', True)
    compute_from_rgb = rospy.get_param('~compute_from_rgb', True)
    use_log_diff = rospy.get_param('~use_log_diff', False)
    method = rospy.get_param('~method', '')

    original_image_publisher_ = rospy.Publisher('original_images', Image, queue_size=10)
    events_image_publisher_ = rospy.Publisher('events_images', Image, queue_size=10)
    visual_events_image_publisher_ = rospy.Publisher('visual_events_images', Image, queue_size=10)

    if source_type == 'camera_device':
        camera_device_id = rospy.get_param('~camera_device_id', 0)
        rospy.loginfo('[event_image_streamer] Accessing camera device: {}'.format(camera_device_id))
        try:
            camera_device_ = cv2.VideoCapture(int(camera_device_id))
        except Exception as e:
            rospy.loginfo('[event_image_streamer] Could not access specified camera device!')
            print('Error:', e)
            sys.exit()

        if camera_device_.isOpened():
            rospy.loginfo('[event_image_streamer] Successfully opened camera device')
            # _, previous_image = camera_device_.read()
        else:
            rospy.loginfo('[event_image_streamer] Could not open camera device!')
            sys.exit()
    elif source_type == 'ros_topic':
        image_topic = rospy.get_param('~image_topic', '/camera/color/image_raw')
        image_subscriber = rospy.Subscriber(image_topic, Image, image_callback)

        rospy.loginfo('[event_image_streamer] Subscribing to image topic: {}'.format(image_topic))
        rospy.loginfo('[event_image_streamer] Waiting for reception of first image message...')
        try:
            while current_image_msg_ is None:
                rospy.sleep(0.1)
        except (KeyboardInterrupt, rospy.ROSInterruptException):
            rospy.loginfo('[event_image_streamer] Terminating...')
            sys.exit()

        # rospy.loginfo('[event_image_streamer] Received first image message')
        # try:
        #     previous_image = bridge.imgmsg_to_cv2(current_image_msg_, "bgr8")
        # except CvBridgeError as e:
        #     rospy.logwarn('[event_image_streamer] Failed to convert image message to opencv format!')
        #     print('Error:', e)
        #     sys.exit()
    else:
        rospy.logerr('[event_image_streamer] Invalid source type! Must be either camera_device or ros_topic')
        sys.exit()

    # e_camera_emulator = EventCameraEmulator()

    ## pyDVS Thread Starting:
    ## -------------------------------------------------------------------------
    running = Value('i', 1)

    spikes_copy_queue = Queue()

    spike_queue = Queue()
    # spike_emitting_proc = Process(target=emitting_thread, 
    #                             args=(spike_queue, running))
    # spike_emitting_proc.start()

    img_queue = Queue()
    spike_gen_proc = Process(target=processing_thread, 
                           args=(img_queue, spike_queue, running, max_time_ms, spikes_copy_queue))
                           # args=(img_queue, spike_queue, running, max_time_ms))
    spike_gen_proc.start()


    rospy.loginfo('[event_image_streamer] Streaming emulated event images')
    try:
        while not rospy.is_shutdown() and running.value == 1:
            if source_type == 'camera_device':
                _, current_image = camera_device_.read()
            elif source_type == 'ros_topic':
                try:
                    current_image = bridge.imgmsg_to_cv2(current_image_msg_, "bgr8")
                except CvBridgeError as e:
                    rospy.logwarn('[event_image_streamer] Failed to convert image message to opencv format!')
                    print('Error:', e)
                    continue

            img = current_image

            ## pyDVS Main Loop Ops:
            ## -------------------------------------------------------------------------
            is_first_pass = True

            if is_first_pass:
                height, width, _ = img.shape
                new_height = cam_res
                new_width = int( float(new_height*width)/float(height) )
                col_from = (new_width - cam_res)//2
                col_to = col_from + cam_res

                is_first_pass = False

            img = preprocess_img_for_pydvs(img, width, height, col_from, col_to)
            img_queue.put(img)

            ## +++ Ahmed: Analyzing data:
            with open('/home/ahmed/tmp/pydvs_img.pkl', 'wb') as f:
                pickle.dump(img, f)

            spikes_copy = spikes_copy_queue.get()
            if spikes_copy is None:
                continue
            events_image = spikes_copy
            visual_events_image = get_visual_events_image_pydvs(events_image)

            if publish_output:
                events_image_msg = bridge.cv2_to_imgmsg(events_image, encoding="passthrough")
                events_image_msg.header.stamp = rospy.Time.now()
                events_image_publisher_.publish(events_image_msg)

                visual_events_image_msg = bridge.cv2_to_imgmsg(visual_events_image, encoding="bgr8")
                visual_events_image_msg.header.stamp = rospy.Time.now()
                visual_events_image_publisher_.publish(visual_events_image_msg)

                original_image_publisher_.publish(bridge.cv2_to_imgmsg(current_image, encoding="bgr8"))

            if display_output:
                if not display_combined_images:
                    cv2.imshow('Original Camera stream', current_image) 
                    cv2.imshow('Simulated Event Camera stream', visual_events_image)
                else:
                    img_rgb = cv2.cvtColor(img.astype(np.uint8), cv2.COLOR_GRAY2BGR)
                    img_rgb[spikes_copy == 1] = [255., 0., 0.]
                    cv2.imshow('Simulated Event Camera stream', img_rgb)
                cv2.waitKey(1)

            try:
                rate.sleep()      ## NOTE: this can not be used with display_output, since cv windows hang
            except rospy.ROSTimeMovedBackwardsException as e:
                rospy.logwarn('[event_image_streamer] Caught ROSTimeMovedBackwardsException when executing rate.sleep(). '
                               'This can happen when incoming messages had stopped, and have just resumed publishing.')
    except (KeyboardInterrupt, rospy.ROSInterruptException):
        rospy.loginfo('[event_image_streamer] Stopping node')
        if source_type == 'camera_device':
            camera_device_.release() 
        if display_output:
            cv2.destroyAllWindows() 

    img_queue.put(None)
    spike_gen_proc.join()
    print("generation thread stopped")

    spike_queue.put(None)


## --------------------------------------------------------------------------------------
            # cv2.imwrite('/home/ahmed/tmp/ece_sample_rgb_image_1.png', previous_image)
            # cv2.imwrite('/home/ahmed/tmp/ece_sample_rgb_image_2.png', current_image)

            # if compute_from_rgb:
            #     events_image = e_camera_emulator.get_events_image_rgb(current_image, previous_image, theta, record_off_events, register_off_events_as_on, use_log_diff=use_log_diff, method=method)
            # else:
            #     ## Baseline method: compute events from grayscale images:
            #     events_image = e_camera_emulator.get_events_image(current_image, previous_image, theta, record_off_events, register_off_events_as_on, use_log_diff=use_log_diff)

            # visual_events_image = e_camera_emulator.get_visual_events_image(events_image)

